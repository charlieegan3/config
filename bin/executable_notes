#!/usr/bin/env ruby

require "yaml"

pwd = ENV["PWD"]

def make_row(items)
  "|" + items.join("|") + "|\n"
end

def make_table(headers, columns)
  table = make_row(headers)
  table += make_row([headers.length.times.map {|e|"---"}])

  if headers.empty? || columns.empty?
    return ""
  end

  max_items = columns.max_by {|e| e.length}.length

  for i in 0...max_items
    items = []
    columns.each do |col|
      if col[i].nil?
        items.push(" ")
      else
        items.push(col[i])
      end
    end

    table += make_row(items)
  end

  table
end

##############################################################################
# create index files
##############################################################################
list_items = []

all_dirs = Dir.glob("#{pwd}/**/*/")

dirs = ["#{pwd}/"]
all_dirs.each do |dir|
  dirs.push(dir)
end

# get any manually created indexes
dirs += Dir.glob("#{pwd}/**/index.md").map { |e| e.delete_suffix("index.md") }
dirs.uniq!

# make sure an index is in place
dirs.each do |dir|
  File.write(dir+"index.md", "index")
end

# create each index with TOC
dirs.each do |dir|
  items = { dirs: [], files: []}

  # list the files and dirs for the TOC
  count = 0
  Dir.glob("#{dir}*").each do |e|
    if File.directory?(e)
      count += 1
      if File.exists?(e+"/index.md")
        icon = ""
        if File.exists?(e+"/meta.yaml")
          metadata = YAML.load_file(e+"/meta.yaml")
          icon = metadata.dig("icon")
        end
        items[:dirs].push(["./"+e.split("/").last+"/index.md", e.split("/").last, icon])
      else
        items[:dirs].push(e.split("/").last)
      end
    elsif e.include? ".md"
      count += 1
      unless e.include? "index.md"
        items[:files].push(["./"+e.split("/").last, e.split("/").last.delete_suffix(".md"), ""])
      end
    end
  end

  if count == 0
    next
  end

  # generate the markdown for the TOC
  headers = []
  cols = []
  if !items[:dirs].empty?
    headers.push("Sections")

    col = []
    items[:dirs].sort_by { |e| e.kind_of?(Array) ? e[1] : e }.each do |i|
      if i.kind_of?(Array)
        col.push("[[#{i[0]}|#{i[2]}#{i[1]}]]")
      else
        col.push("#{i}")
      end
    end
    cols.push(col)
  end
  if !items[:files].empty?
    headers.push("Files")

    col = []
    items[:files].sort_by {|e|e[1]}.each do |i|
      col.push("[[#{i[0]}|#{i[1]}]]")
    end
    cols.push(col)
  end

  icon = ""
  if File.exists?(dir+"/meta.yaml")
    metadata = YAML.load_file(dir+"/meta.yaml")
    icon = metadata.dig("icon")
  end

  index_name = dir.split("/").last
  content = "# #{icon}#{index_name}\n\n" + make_table(headers, cols) +"\n"

  File.write(dir+"index.md", content)
end

##############################################################################
# create breadcrumbs
##############################################################################

Dir.glob("#{pwd}/**/*.md").each do |file|
  breadcrumbs = file.delete_prefix(pwd).split("/").reject {|e|e==""}
  if breadcrumbs.empty?
    next
  end

  breadcrumb_items = [
    [(breadcrumbs.length-1).times.map { |e| "../" }.join+"index", "Root"]
  ]
  breadcrumbs.each_with_index do |e, i|
    if i < breadcrumbs.length - 2
      breadcrumb_items.push([
        (breadcrumbs.length - i - 2).times.map { |e| "../" }.join + "index",
        e,
      ])
    end
  end


  if breadcrumbs.last != "index.md"
    if !breadcrumbs[-2].nil?
      breadcrumb_items.push(["./index", breadcrumbs[-2]])
    end
    breadcrumb_items.push(breadcrumbs.last.delete_suffix(".md"))
  else
    if breadcrumbs.length < 2
      next
    end
    breadcrumb_items.push(breadcrumbs[-2].delete_suffix(".md"))
  end

  links = breadcrumb_items.map do |e|
    if e.kind_of?(Array)
      "[[#{e[0]}|#{e[1]}]]"
    else
      e
    end
  end.join(" / ")

  new_content = "<sup>/ #{links}</sup>"

  lines = File.readlines(file).map(&:chomp)

  if lines.first.start_with? "<sup>"
    lines[0] = new_content
  else
    lines = lines.unshift("")
    lines = lines.unshift(new_content)
  end

  File.write(file, lines.join("\n"))
end
